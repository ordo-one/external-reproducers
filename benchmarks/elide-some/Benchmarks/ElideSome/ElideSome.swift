// Benchmark boilerplate generated by Benchmark

import Benchmark
import Foundation

let benchmarks = {
    var classTarget = ClassIncrementer()
    var structTarget = StructIncrementer()

    let anyStorage: any ClassIncrementable = ClassUnderlier()
    let someStorage: some ClassIncrementable = ClassUnderlier()
    let concreteStorage = ClassUnderlier()

    var varAnyStorage: any ClassIncrementable = ClassUnderlier()
    var varSomeStorage: some ClassIncrementable = ClassUnderlier()
    var varConcreteStorage = ClassUnderlier()

    var varAnyStructStorage: any StructIncrementable = StructUnderlier()
    var varSomeStructStorage: some StructIncrementable = StructUnderlier()
    var varConcreteStructStorage = StructUnderlier()

    Benchmark.defaultConfiguration.scalingFactor = .mega
    Benchmark.defaultConfiguration.warmupIterations = 0
    Benchmark.defaultConfiguration.maxDuration = .seconds(3)
    Benchmark.defaultConfiguration.timeUnits = .microseconds
    
    // MARK: Let any storage with class Target
    Benchmark("letAnyStorageWithExistential") { benchmark in
        anyStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(classTarget.existential(anyStorage))
        }
    }

    Benchmark("letAnyStorageWithGeneric") { benchmark in
        anyStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(classTarget.generic(anyStorage))
        }
    }

    Benchmark("letAnyStorageWithConcrete") { benchmark in
        anyStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(classTarget.opaque(anyStorage))
        }
    }

    // MARK: Let some storage with class Target
    Benchmark("letSomeStorageWithExistential") { benchmark in
        someStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(classTarget.existential(someStorage))
        }
    }

    Benchmark("letSomeStorageWithGeneric") { benchmark in
        someStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(classTarget.generic(someStorage))
        }
    }

    Benchmark("letSomeStorageWithConcrete") { benchmark in
        someStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(classTarget.opaque(someStorage))
        }
    }

    // MARK: Let concrete storage with class Target
    Benchmark("letConcreteStorageWithExistential") { benchmark in
        concreteStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(classTarget.existential(concreteStorage))
        }
    }

    Benchmark("letConcreteStorageWithGeneric") { benchmark in
        concreteStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(classTarget.generic(concreteStorage))
        }
    }

    Benchmark("letConcreteStorageWithConcrete") { benchmark in
        concreteStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(classTarget.opaque(concreteStorage))
        }
    }

    // MARK: Var any storage with class Target
    Benchmark("varAnyStorageWithExistential") { benchmark in
        varAnyStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(classTarget.existential(varAnyStorage))
        }
    }

    Benchmark("varAnyStorageWithGeneric") { benchmark in
        varAnyStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(classTarget.generic(varAnyStorage))
        }
    }

    Benchmark("varAnyStorageWithConcrete") { benchmark in
        varAnyStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(classTarget.opaque(varAnyStorage))
        }
    }

    // MARK: Var some storage with class Target
    Benchmark("varSomeStorageWithExistential") { benchmark in
        varSomeStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(classTarget.existential(varSomeStorage))
        }
    }

    Benchmark("varSomeStorageWithGeneric") { benchmark in
        varSomeStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(classTarget.generic(varSomeStorage))
        }
    }

    Benchmark("varSomeStorageWithConcrete") { benchmark in
        varSomeStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(classTarget.opaque(varSomeStorage))
        }
    }

    // MARK: Var concrete storage with class Target
    Benchmark("varConcreteStorageWithExistential") { benchmark in
        varConcreteStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(classTarget.existential(varConcreteStorage))
        }
    }

    Benchmark("varConcreteStorageWithGeneric") { benchmark in
        varConcreteStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(classTarget.generic(varConcreteStorage))
        }
    }

    Benchmark("varConcreteStorageWithConcrete") { benchmark in
        varConcreteStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(classTarget.opaque(varConcreteStorage))
        }
    }

    // MARK: Inout var any storage with class Target
    Benchmark("varAnyStorageWithInoutExistential") { benchmark in
        varAnyStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(classTarget.ioexistential(&varAnyStorage))
        }
    }

    Benchmark("varAnyStorageWithInoutGeneric") { benchmark in
        varAnyStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(classTarget.iogeneric(&varAnyStorage))
        }
    }

    Benchmark("varAnyStorageWithInoutConcrete") { benchmark in
        varAnyStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(classTarget.ioopaque(&varAnyStorage))
        }
    }

    // MARK: Inout var some storage WithInout class Target

    Benchmark("varSomeStorageWithInoutGeneric") { benchmark in
        varSomeStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(classTarget.iogeneric(&varSomeStorage))
        }
    }

    Benchmark("varSomeStorageWithInoutConcrete") { benchmark in
        varSomeStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(classTarget.ioopaque(&varSomeStorage))
        }
    }

    // MARK: Inout var concrete storage class Target

    Benchmark("varConcreteStorageWithInoutGeneric") { benchmark in
        varConcreteStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(classTarget.iogeneric(&varConcreteStorage))
        }
    }

    Benchmark("varConcreteStorageWithInoutConcrete") { benchmark in
        varConcreteStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(classTarget.ioopaque(&varConcreteStorage))
        }
    }

    // MARK: Inout var any storage with class Target
    Benchmark("varAnyStructStorageWithInoutExistential") { benchmark in
        varAnyStructStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(structTarget.existential(&varAnyStructStorage))
        }
    }

    Benchmark("varAnyStructStorageWithInoutGeneric") { benchmark in
        varAnyStructStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(structTarget.generic(&varAnyStructStorage))
        }
    }

    Benchmark("varAnyStructStorageWithInoutConcrete") { benchmark in
        varAnyStructStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(structTarget.opaque(&varAnyStructStorage))
        }
    }

    // MARK: Inout var some storage WithInout class Target

    Benchmark("varSomeStructStorageWithInoutGeneric") { benchmark in
        varSomeStructStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(structTarget.generic(&varSomeStructStorage))
        }
    }

    Benchmark("varSomeStructStorageWithInoutConcrete") { benchmark in
        varSomeStructStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(structTarget.opaque(&varSomeStructStorage))
        }
    }

    // MARK: Inout var concrete storage class Target

    Benchmark("varConcreteStructStorageWithInoutGeneric") { benchmark in
        varConcreteStructStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(structTarget.generic(&varConcreteStructStorage))
        }
    }

    Benchmark("varConcreteStructStorageWithInoutConcrete") { benchmark in
        varConcreteStructStorage.reset()
        for _ in benchmark.scaledIterations {
            blackHole(structTarget.opaque(&varConcreteStructStorage))
        }
    }
}
